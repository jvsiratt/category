int_sets_category: THEORY
 BEGIN

  xset: TYPE = setof[int]
  xfun: TYPE = [a:xset, b:xset, f:[{x:int | a(x)} -> {x:int | b(x)}]]
  domain: [xfun -> xset] = LAMBDA (f:xfun): proj_1(f)
  codomain: [xfun -> xset] = LAMBDA (f:xfun): proj_2(f)
  identity: [xset -> xfun] = LAMBDA (x:xset): (x,x,LAMBDA (a:{y:int | x(y)}):a)
  composition: [[f:xfun, {g:xfun | codomain(g) = domain(f)}] -> xfun] =
   LAMBDA (f:xfun, g:xfun | codomain(g) = domain(f)):
    (domain(g), codomain(f), LAMBDA (a:{y:int | (domain(g))(y)}):(proj_3(f))((proj_3(g))(a)))

% Stuck proving assuming tccs involving identity and composition.
% Problem: subtype {y:int | (domain(A,A,LAMBDA ...))(y)} will
%          not resolve to {y:int | A(y)}. If I can work this out
%          should be able to eta-reduce the parent LAMBDA expression
%          to get the expression simplified down to
%          (proj_1(f), proj_2(f), proj_3(f)) = f
%
%  xfun_extensionality: AXIOM
%   FORALL (f:xfun): f = (domain(f), codomain(f), proj_3(f))
%  subtype_case: AXIOM
%   FORALL (A:xset, f:xfun | domain(f) = A, a:{y:int | domain(f)(y)}):
%    A(a)

  IMPORTING category[xset,xfun,domain,codomain,identity,composition]


 END int_sets_category
